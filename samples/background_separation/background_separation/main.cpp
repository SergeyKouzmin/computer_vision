//opencv
#include <opencv2/highgui/highgui.hpp>
#include "opencv2/imgproc.hpp"
#include <opencv2/imgproc/imgproc.hpp>
#include <opencv2/video/background_segm.hpp>
//C
#include <stdio.h>
//C++
#include <iostream>
#include <sstream>

const float PERIM_SCALE = 10.0;
const int CLOSE_ITR = 1;

using namespace cv;
using namespace std;

typedef std::vector<cv::Point> Contour;

typedef std::vector< std::vector<cv::Point> > Contours;

// Global variables
Mat frame; //current frame
Contours maskContours;
Mat fgMaskMOG; //fg mask generated by MOG method
Mat fgMaskMOG2; //fg mask fg mask generated by MOG2 method
Ptr<BackgroundSubtractor> pMOG; //MOG Background subtractor
Ptr<BackgroundSubtractorMOG2> pMOG2; //MOG2 Background subtractor
int keyboard; //input from keyboard

void processVideo(char* videoFilename);
void processImages(char* firstFrameFilename);

int thresh = 100;
int levels = 3;

void throwError(const std::string& msg) {
    cerr << "Error: " << msg << endl;
    exit(EXIT_FAILURE);
}

cv::Mat morphologyFilter(cv::Mat& img) {
        if (!img.isContinuous()) {
                throwError("Parammeter 'img' in 'morphologyFilter' must be continuous");
        }

        cv::Mat buf(img.size(), img.type());
        buf.setTo(0);
        cv::morphologyEx(img, buf, MORPH_OPEN, cv::Mat(), cv::Point(-1, -1), CLOSE_ITR);
        cv::morphologyEx(img, buf, MORPH_CLOSE, cv::Mat(), cv::Point(-1, -1), CLOSE_ITR);

        return buf;
}

cv::Mat connectedComponentsFilter(cv::Mat& curFrame, cv::Mat& img) {

    if (!img.isContinuous()) {
        throwError("Parammeter 'img' in 'connectedComponentsFilter' must be continuous");
    }

    //morphology_(img);

    maskContours.clear();

    // Отрисовать найденные области обратно в маску
    cv::Mat result(img.size(), img.type());
    result.setTo(0);

    cv::Mat kmeans_data(img.size(), img.type());
    kmeans_data.setTo(0);

    cv::findContours(img, maskContours, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);
    size_t i = 0;

    while (i < maskContours.size()) {
        Contour& contour = maskContours[i];

        cv::Mat contourMat(contour, false);
        double len = cv::arcLength(contourMat, true);

        if (len * PERIM_SCALE < img.size().height + img.size().width) {
            // Отбрасываем контуры со слишком маленьким периметром.
            maskContours.erase(maskContours.begin() + i);
        } else {
            // Достаточно большие контуры аппроксимируем указанным методом.
            Contour newContour;

            // Методы аппроксимации.
            //cv::approxPolyDP(contourMat, newContour, CHAIN_APPROX_SIMPLE, true);
            cv::convexHull(contourMat, newContour, true);

            maskContours[i] = newContour;

            cv::Mat newContourMat(newContour, false);
            Rect boundingRect = cv::boundingRect(newContourMat);
            cv::rectangle(curFrame, boundingRect, cv::Scalar(255));

            cv::Point pointLeft(boundingRect.x, boundingRect.y);
            cv::Point pointRight(boundingRect.x + boundingRect.width, boundingRect.y + boundingRect.height);
            cv::circle(kmeans_data, pointLeft, 2, cv::Scalar(255), FILLED, LINE_AA );
            cv::circle(kmeans_data, pointRight, 2, cv::Scalar(255), FILLED, LINE_AA );

            cv::imshow("kmeans_data", kmeans_data);


            i++;
        }
    }


    if (!maskContours.empty()) { // Обходим баг OpenCV 2.1.0; в 2.3.1 он уже исправлен.
        cv::drawContours(result, maskContours, -1, cv::Scalar(255), FILLED);

    }
    return result;
}

void drawObjects(Mat& curFrame, Mat& img) {

    Mat result;// = img.clone();
    //blur( img, result, Size(3,3) );
    //Canny( result, result, 20, 300, 5);
    Mat resultMorph = morphologyFilter(img);
    cv::medianBlur(resultMorph, resultMorph, 5);
    Mat resultConnectComp = connectedComponentsFilter(curFrame, resultMorph);

    //cvtColor( img, grayImg, COLOR_BGR2GRAY );
    /*blur( grayImg, grayImg, Size(3,3) );
    */
    /*vector<vector<Point> > contours;
    vector<Vec4i> hierarchy;

    /// Detect edges using canny
    Canny( grayImg, grayImg, thresh, thresh*2, 3 );
    /// Find contours
    findContours( grayImg, contours, hierarchy, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE, Point(0, 0) );
    for( int i = 0; i< contours.size(); i++ )
    {
        Scalar color = Scalar( 255, 255, 255);
        drawContours( grayImg, contours, i, color, 2, 8, hierarchy, 0, Point() );
    }*/

    /// Show in a window
    imshow( "Contours", resultConnectComp);
}

int main(int argc, char* argv[]) {

    //create GUI windows
    namedWindow("Frame");
    namedWindow("FG Mask MOG");
    namedWindow("FG Mask MOG 2");
    namedWindow( "Contours" );

    //create Background Subtractor objects

    //int history=200, int nmixtures=5,double backgroundRatio=0.7, double noiseSigma=0)
    //pMOG = createBackgroundSubtractorMOG(100, 5, 0.5, 0.3); //MOG approach
    pMOG = createBackgroundSubtractorMOG();

    //int history=500, double varThreshold=16, bool detectShadows=true
    pMOG2 = createBackgroundSubtractorMOG2(500, 16, true); //MOG2 approach
    pMOG2->setShadowValue(0);

    if (argc < 2) {
        throwError("Must be one parameters - name of file");
    }
    processVideo(argv[1] /*"/home/sergey/iq720p.mp4"*/);

    //destroy GUI windows
    destroyAllWindows();
    return EXIT_SUCCESS;
}

void processVideo(char* videoFilename) {
    //create the capture object
    VideoCapture capture(videoFilename);
    if(!capture.isOpened()){
        //error in opening the video input
        cerr << "Unable to open video file: " << videoFilename << endl;
        exit(EXIT_FAILURE);
    }

    //read input data. ESC or 'q' for quitting
    while( (char)keyboard != 'q' && (char)keyboard != 27 ){

        //read the current frame
        if(!capture.read(frame)) {
            cerr << "Unable to read next frame." << endl;
            cerr << "Exiting..." << endl;
            exit(EXIT_FAILURE);
        }

        //update the background modelS
        pMOG->apply(frame, fgMaskMOG);
        pMOG2->apply(frame, fgMaskMOG2);

        //get the frame number and write it on the current frame
        stringstream ss;
        rectangle(frame, cv::Point(10, 2), cv::Point(100,20),
                  cv::Scalar(255,255,255), -1);
        ss << capture.get(CAP_PROP_POS_FRAMES);
        string frameNumberString = ss.str();
        putText(frame, frameNumberString.c_str(), cv::Point(15, 15),
                FONT_HERSHEY_SIMPLEX, 0.5 , cv::Scalar(0,0,0));


        drawObjects(frame, fgMaskMOG2);

        //show the current frame and the fg masks
        imshow("Frame", frame);
        imshow("FG Mask MOG", fgMaskMOG);
        imshow("FG Mask MOG 2", fgMaskMOG2);

        //get the input from the keyboard
        keyboard = waitKey( 30 );
    }
    //delete capture object
    capture.release();
}
